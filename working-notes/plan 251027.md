
### 重构计划描述

#### **阶段 0: 前期准备 - 代码清洁与类型统一**

**目标**: 消除代码库中的基础性混乱，为后续重构扫清障碍。

**工作描述**:
1.  **统一 `Node` 和 `Edge` 类型**:
    *   在整个项目中，废除所有自定义的 `Node` 和 `Edge` 类型定义（例如在 `model` 文件夹中）。
    *   将所有对这些自定义类型的引用，全部替换为从 `@xyflow/react` 导入的官方类型。
    *   对于节点的数据负载，应使用泛型进行约束，例如 `Node<MyNodeData>`，其中 `MyNodeData` 是你自己定义的数据接口。
    *   此项工作完成后，应删除所有冗余的类型定义文件。

#### **阶段 1: 核心逻辑修复 - 重写求值引擎**

**目标**: 修复 `evaluateNodeAndDownstream` 的根本性逻辑错误，并使其能够应对并发计算请求。这是整个系统的核心，必须优先保证其正确性。

**工作描述**:
1.  **废除递归求值**:
    *   当前的 `async` 递归调用 `evaluateNodeAndDownstream` 的方式是错误的。在并发环境中，它无法保证下游节点在计算时，其所有上游依赖都已更新到
    最新状态。
2.  **实现有规划的、简单串行执行的计算流程（作为过渡方案）**:
    *   **确定计算范围**: 当一个或多个节点变化时，先找出这些变化的节点，以及所有依赖它们结果的下游节点，分析出计算范围。
    *   **规划计算顺序**: 根据节点间的依赖关系，规划出一个正确的、从上游到下游的计算顺序。这确保在计算一个节点时，它需要的数据都已经准备好了。（这在算法上被称为“拓扑排序”）。
    *   **按计划执行**: 按照规划好的顺序，用一个循环依次计算范围内的每个节点。计算的中间结果会立即对后续节点的计算可见。
    *   **一次性更新状态**: 所有计算都完成后，将全部结果一次性更新到 `evalStore`，避免界面闪烁。

3.  **处理并发与竞态问题**:
    *   **引入版本/时间戳**: 为每一次由用户输入触发的“计算请求”引入一个唯一的、递增的 ID 或时间戳。维护一个 ref 来记录当前正在执行的计算任务的版本号。
    *   **执行前检查**: 在 `for` 循环的每一步（或者至少在开始时），检查当前正在执行的计算任务的版本号是否仍然是“最新”的版本号。
    *   **过时任务中止**: 如果在计算过程中，一个新的、更高版本的计算请求被触发，那么当前这个旧版本的计算任务应该立即中止，以避免用过时的数据覆盖
    新的结果。一个简单的 `if (currentVersion !== latestVersion) return;` 即可实现。这解决了“计算需要时间，而在计算完之前又订阅到变动”的问题。
    *   **耐受性**: 这种“中止并重算”的模式天然地让系统耐受多次重复计算。我们不关心计算是否冗余，只关心最终显示在屏幕上的是最新输入所对应的结果。

#### **阶段 2: 宏观架构重构**

**目标**: 应用我们之前讨论的“双 store + Host 组件”架构，实现 UI 状态与计算状态的彻底分离。

**工作描述**:
1.  **创建 Stores**:
    *   `uiStore`: 负责存储与 React Flow UI 直接相关的状态。它应该是 `code` 和 `controls` **用户设定值** (`value`) 的唯一数据源 (Source of Truth)。它包含 `nodes`, `edges` 以及操作它们的回调函数 (`onNodesChange` 等)。
    *   `evalStore`: 负责存储所有计算产生的结果。它应该是 `controls` **定义** (`min`, `max`, `step`)、`outputs`, `errors`, `logs` 的唯一数据源。

2.  **实现 `CanvasInstance` 容器与 Context**:
    *   创建一个 `CanvasInstance` 组件，它负责在内部创建 `uiStore` 和 `evalStore` 的实例。
    *   将 `uiStore` 实例通过 `UIStoreContext.Provider` 向下传递。
    *   创建一个 `EvalController` 实例（包装 `evalStore`），并通过 `EvalControllerContext.Provider` 向下传递。

3.  **实现 `CanvasEvalHost` 逻辑组件**:
    *   创建一个无 UI 的 `CanvasEvalHost` 组件，放置在 `CanvasInstance` 内部。
    *   它通过 Context 消费 `uiStore` 和 `EvalController`。
    *   它使用 `useStore` **只订阅 `uiStore` 中与计算相关的输入数据**（例如节点代码、边、控件值）。
    *   在 `useEffect` 中，当这些输入变化时，它调用 `EvalController` 的方法来触发（已在阶段 1 中重构好的）计算流程。**它本身不订阅 `evalStore` 的任何数据。**

4.  **拆分 `CanvasUI` 组件**:
    *   将现有的 `Canvas` 组件重构为一个纯粹的 `CanvasUI` 组件。
    *   它通过 Context 消费 `uiStore`，获取 `nodes`, `edges` 等数据并渲染 React Flow 画布。

5.  **改造节点组件 (`TextNode` 等)**:
    *   节点组件现在通过 Context 消费 `EvalController`。
    *   它们调用 Controller 提供的自定义 Hook (例如 `controller.useNodeOutput(nodeId)`) 来订阅和显示来自 `evalStore` 的计算结果。

#### **阶段 3: 持久化层**

**目标**: 实现画布状态的保存与加载。

**工作描述**:
1.  创建一个全局的 `persistenceStore` 或一个独立的 `PersistenceService`。
2.  实现 `save` 功能：该功能被触发时，读取 `uiStore` 的当前状态，将其序列化为 JSON，并保存到 LocalStorage 或其他地方。**注意：只保存 `uiStore`**，因为 `evalStore` 的状态是可被计算推导的。
3.  实现 `load` 功能：从存储中读取 JSON 数据，反序列化后，用这些数据来初始化 `uiStore`。`CanvasEvalHost` 会自动监听到 `uiStore` 的初始化数据并触发一次完整的计算。








