## Desmos 预览功能及计算层重构计划

### 1. 计算层改造：从“传引用”到“传值” (已完成)

-   **现状确认**: 当前计算层在节点间传递对象类型的数据时，采用的是“传引用” (pass-by-reference) 方式。这会导致一个节点对数据的修改可能意外影响到其他节点，存在副作用风险。
-   **改造目标**: 将计算层的数据传递机制修改为“传值” (pass-by-value)，以保证数据流的单向性和安全性，符合用户对“流水线”的心智模型。
-   **实施方案**: 在计算引擎的核心逻辑中（`useCanvasEval.ts`），当为下游节点收集上游节点的输出数据时，统一使用 `structuredClone()` 对每个输出值进行深拷贝。这样可以确保每个节点接收到的输入都是一份全新的、独立的数据副本。
-   **远期规划**: 本次重构先专注于实现完全的“传值”。未来可以考虑为需要极致性能的场景，增加一个由用户显式选择的“传引用”的“逃生舱口 (escape hatch)”，但这不是当前阶段的任务。

### 2. Desmos 预览功能重构

#### Phase 1：建立健壮的基础结构 (当前任务)

1.  **使用自定义边 (Edge) 管理关系**:
    -   废弃当前在 `useCanvasUIData` 中使用的 `desmosPreviewLinks` 哈希表。
    -   引入一种新的、自定义的边类型，例如 `desmosPreviewEdge`。
    -   当创建一个 Desmos 预览节点时，同时创建一条 `desmosPreviewEdge`，从源 `TextNode` 连接到这个新的 `DesmosPreviewNode`。
    -   关系信息（例如，源输出的名称 `sourceOutputName`）存储在这条边的 `data` 属性中。这样，图（节点和边的集合）本身就成为关系的唯一真实来源。

2.  **依赖计算层进行数据同步**:
    -   `DesmosPreviewNode` 将不再直接从 `TextNode` 拉取数据或通过特殊方法更新。
    -   它将作为一个普通的下游节点，通过新改造的“传值”计算层，直接读取计算层里的本节点数据，这个数据是上游 `TextNode` 输出的 `desmosState` 数据的副本。

3.  **简化状态管理（只读预览）**:
    -   在 Phase 1，为了简化逻辑，`DesmosPreviewNode` 将是**完全只读**的。它的所有状态都严格由上游传递过来的 `desmosState` 决定。
    -   暂时放弃用户与 Desmos 计算器的交互能力（或者交互所做的更改不会被保存）。这意味着预览节点自身不维护任何独立状态（如视图的缩放/平移）。

4.  **节点生命周期管理**:
    -   **创建**: 在 `OutputDisplay` 组件中触发创建操作时，应原子性地创建一个 `DesmosPreviewNode` 和一条连接它的 `desmosPreviewEdge`。
    -   **删除**: 利用 React Flow 的特性，当删除源节点或预览节点时，与之相连的边也会被自动删除。需要增加逻辑来自动清理因源节点被删除而产生的“孤儿”预览节点。

#### Phase 2：增强交互性 (远期规划)

-   在 `DesmosPreviewNode` 的 `data` 属性中，独立存储它自身的 UI 状态，例如 `desmosViewportState`（记录用户平移缩放的视图信息）或用户在预览窗口中临时调整的变量值。
-   渲染时，将上游传入的 `desmosState`（核心数据）与节点自身的 `desmosViewportState`（视图状态）合并，再交给 Desmos 渲染。
-   当用户在预览窗口中交互时，只更新其自身的 `desmosViewportState`，不影响上游数据源。
